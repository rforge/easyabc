\documentclass[a4paper]{article}

\title{\texttt{EasyABC}: a \texttt{R} package to perform efficient approximate Bayesian computation sampling schemes}
\author{Franck Jabot, Thierry Faure, Nicolas Dumoulin}

\SweaveOpts{echo=FALSE}

\begin{document}

\maketitle

\tableofcontents

\section{Summary}
The aim of this vignette is to present the features of the \texttt{EasyABC} package.
Section 2 describes the different algorithms available in the package.
Section 3 details how to install the package and the formatting requirements.
Section 4 presents a detailed worked example.

\section{Overview of the package EasyABC}
\texttt{EasyABC} enables to launch various ABC schemes and to retrieve the ouputs of the simulations, so as to perform post-processing treatments with the various R tools available. \texttt{EasyABC} is also able to launch the simulations on multiple cores of a multi-core computer.
Three main types of ABC schemes are available in EasyABC: the standard rejection algorithm of Pritchard et al. (1999), sequential schemes first proposed by Sisson et al. (2007), and coupled to MCMC schemes first proposed by Marjoram et al. (2003).
Four different sequential algorithms are available: the ones of Beaumont et al. (2009), Drovandi and Pettitt (2011), Del Moral et al. (2012) and Lenormand et al. (2012).
Three different MCMC schemes are available: the ones of Marjoram et al. (2003), Wegmann et al. (2009) and a modification of Marjoram et al. (2003)'s algorithm in which the tolerance and proposal range are determined by the algorithm, following the modifications of Wegmann et al. (2009).
Details on how to implement these various algorithms with \texttt{EasyABC} are given in the manual pages of each function and an example is detailed in Section 4.

\section{Installation and requirements}
\subsection{Installing the package}
To install the \texttt{EasyABC} package from \texttt{R}, simply type:
<<echo=TRUE,print=TRUE>>=
#install.packages("EasyABC")
@

Once the package is installed, it needs to be loaded in the current \texttt{R} session to be used:
<<echo=TRUE,print=TRUE>>=
#library(EasyABC)
@

\subsection{The simulation code - for use on a single core}
Users need to develop a simulation code with minimal compatibility constraints. The code can either be a \texttt{R} function or a binary executable file.

If the code is a \texttt{R} function, its argument must be an array of parameter values and it must return an array of summary statistics. If the default option \texttt{use\_seed=TRUE} is chosen, the first parameter value passed to the simulation code corresponds to the seed value to be used by the simulation code to initialize the pseudo-random number generator.  The following parameters are the model parameters.

If the code is a binary executable file, it needs to read the parameter values in a file named 'input' in which each line contains one parameter value, and to output the summary statistics in a file named 'output' in which each summary statistics must be separated by a space or a tabulation.
If the code is a binary executable file, a wrapper \texttt{R} function named '.binary\_model' is available to interface the executable file with the \texttt{R} functions of the \texttt{EasyABC} package (see section 4 below).


\subsection{The simulation code - for use with multiple cores}
Users need to develop a simulation code with minimal compatibility constraints. The code can either be a \texttt{R} function or a binary executable file.

If the code is a \texttt{R} function, its argument must be an array of parameter values and it must return an array of summary statistics. The first parameter value passed to the simulation code corresponds to the number of cores used by the \texttt{EasyABC} function, the second parameter corresponds to the seed value to be used by the simulation code to initialize the pseudo-random number generator. The following parameters are the model parameters.
Note that the \texttt{R} function is unlikely to make use of the first parameter (the number of cores used by the \texttt{EasyABC} function). This constraint is useful to deal with the case where a binary executable file is provided.

If the code is a binary executable file, it needs to have as its single argument an integer \texttt{k} between 1 and the number of cores used by the \texttt{EasyABC} functions. It has to read the parameter values in a file named 'inputk' (where k is the integer passed as argument to the binary code: 'input1', 'input2'...) in which each line contains one parameter value, and to output the summary statistics in a file named 'outputk' (where k is the integer passed as argument to the binary code: 'output1', 'output2'...) in which each summary statistics must be separated by a space or a tabulation.
This construction avoids multiple cores to read/write in the same files.
If the code is a binary executable file, a wrapper \texttt{R} function named '.binary\_model\_cluster' is available to interface the executable file with the \texttt{R} functions of the \texttt{EasyABC} package (see section 4 below).

\subsection{Management of pseudo-random number generators}
To insure that stochastic simulations are independent, the simulation code must either possess an internal way of initializing the seeds of its pseudo-random number generators each time the simulation code is launched.
This can be achieved for instance by initializing the seed to the clock value.
It is often desirable though to have a way to re-run some analyses with similar seed values. 
%#\texttt{EasyABC} offers this possibility by default with the default option \texttt{use\_seed=TRUE,seed\_count=0} where \texttt{seed\_count} can be any integer number.
If this option is chosen, a seed value is provided in the input file as a first (additional) parameter, and incremented by 1 at each call of the simulation code.
This means that the simulation code must be designed so that the first parameter is a seed initializing value.
In the worked example (Section 4), the simulation code \texttt{trait\_model} makes use of this package default option.

\textit{NB:} Note that the multicore versions of the package functions force the use of the default option \texttt{use\_seed=TRUE}, since the seed value is also used to distribute the tasks to each core.

\subsection{The prior matrix}
A matrix containing the range of the prior distribution of the parameters must be supplied. Each line contains the range values for one parameter.
The first (second) column contains the lower (upper) bound of the range.
Note that fixed variable can be passed to the simulation code by putting the same value in the two columns.
\texttt{EasyABC} only manages uniform prior distribution (it will draw a number between the bounds of the range).
Consequently, to deal with non-uniform prior distribution, users should include parameter transformation in their simulation code.
For instance, in the example below (section 4), three parameters are exponentially transformed in the simulation code.

\subsection{The target summary statistics}
An array containing the summary statistics of the data must be supplied (for the sequential and MCMC schemes, not for the simple rejection scheme). The statistics must be in the same order as in the simulation outputs.

\subsection{Building a \texttt{R} function calling a \texttt{C/C++} program}
Users having a \texttt{C/C++} simulation code may wish to construct a \texttt{R} function calling their \texttt{C/C++} program, instead of using the provided wrappers (see sections 3.2 and 3.3).
The procedure is abundantly described in XXX (-> NICO !! Tes sources !). In short, this can be done by:
XXX -> NICO !! 



\section{A worked example}

\subsection{The trait model}
We consider a simple stochastic ecological model hereafter called \texttt{trait\_model}.
This model represents the stochastic dynamics of an ecological community where each species is represented by a set of traits (i.e. characteristics) which determine its competitive ability.
A detailed description and analysis of the model can be found in Jabot (2010).
The model requires four parameters: an immigration rate $I$, and three additional parameters ($h$, $A$ and $\sigma$) describing the way traits determine species competitive ability.
The model additionnally requires two fixed variable: the total number of individuals in the local community $J$ and the number of traits used $n\_t$.
The model outputs four summary statistics: the species richness of the community $S$, its Shannon's index $H$, the mean of the trait value among individuals $MTV$ and the skewness of the trait value distribution $STV$.

\textit{NB:} Three parameters ($I$, $A$ and $\sigma$) have non-uniform prior distributions: instead, their log-transformed values have a uniform prior distribution.
The simulation code \texttt{trait\_model} therefore takes an exponential transform of the values proposed by \texttt{EasyABC} for these parameters at the beginning of each simulation.

In the following, we will use the values $J=500$ and $n\_t=1$, and uniform prior distributions for $ln(I)$ in $[3;5]$, $h$ in [-25;125], $ln(A)$ in $[ln(0.1);ln(5)]$ and $ln(\sigma)$ in $[ln(0.5);ln(25)]$. The simulation code \texttt{trait\_model} reads sequentially $J$, $I$, $A$, $n\_t$, $h$ and $\sigma$.

\textit{NB:} Note that the fixed variables $J$ and $n\_t$ are included in the prior matrix (lines 1 and 4) with their two columns equal to their fixed values:

<<echo=TRUE,print=TRUE>>=
priormatrix=c(500,3,-2.3,1,-25,-0.7,500,5,1.6,1,125,3.2)
dim(priormatrix)<-c(6,2)
priormatrix
@

We will consider an imaginary arbitrary dataset whose summary statistics are $(S,H,MTV,STV) = (100,2.5,20,30000)$:
<<echo=TRUE,print=TRUE>>=
sum_stat_obs=c(100,2.5,20,30000)
@


\subsection{Performing a standard ABC-rejection procedure}
A standard ABC-rejection procedure can be simply performed with the function \texttt{ABC\_rejection}, in precising the number $n$ of simulations to be performed:
<<echo=TRUE,print=TRUE>>=
set.seed(1)
n=10
#ABC_rej<-ABC_rejection(model=trait_model,prior_matrix=priormatrix,nb_simul=n)
#ABC_rej
@

Note that a simulation code \texttt{My\_simulation\_code} can be passed to the function \texttt{ABC\_rejection} with the command:

\texttt{ABC\_rejection(My\_simulation\_code,prior\_matrix=priormatrix,nb\_simul=n)} if it is a \texttt{R} function, or with the command:

\texttt{ABC\_rejection(.binary\_model("./My\_simulation\_code"),prior\_matrix=priormatrix,nb\_simul=n)} if it is a binary executable file.

Simulation outputs can be transparently passed to post-processing tools, like the ones proposed by the \texttt{R} package \texttt{abc} (Csill\'ery et al. 2012):
<<echo=TRUE,print=TRUE>>=
#install.packages("abc")
#library(abc)
#rej<-abc(sum_stat_obs,ABC_rej[,c(2,3,5,6)],ABC_rej[,7:10],tol=0.3,method="rejection")
# simulations selected:
#rej$unadj.values
# their associated summary statistics:
#rej$ss
# their normalized euclidean distance to the data summary statistics:
#rej$dist
@


\subsection{Performing a sequential ABC scheme}
Other functions of the \texttt{EasyABC} package are used in a very similar manner.
To perform the algorithm of Beaumont et al. (2009), one needs to specify the sequence of tolerance levels $tolerance\_tab$ and the number $nb\_simul$ of simulations to obtain below the tolerance level at each iteration:
<<echo=TRUE,print=TRUE>>=
n=10
tolerance=c(8,5)
#ABC_Beaumont<-ABC_sequential(method="Beaumont",model=trait_model,prior_matrix=priormatrix,
#nb_simul=n,summary_stat_target=sum_stat_obs,tolerance_tab=tolerance)
#ABC_Beaumont
@

To perform the algorithm of Drovandi and Pettitt (2011), one needs to specify four arguments: the initial number of simulations $nb\_simul$, the final tolerance level $tolerance\_tab$, the proportion $\alpha$ of best-fit simulations to update the tolerance level at each step, and the target proportion $c$ of unmoved particles during the MCMC jump.
Note that default values $alpha=0.5$ and $c=0.01$ are used if not specified, following Drovandi and Pettitt (2011).
<<echo=TRUE,print=TRUE>>=
n=10
tol=3
alpha=0.5
c=0.7
#ABC_Drovandi<-ABC_sequential(method="Drovandi",model=trait_model,prior_matrix=priormatrix,
#nb_simul=n,summary_stat_target=sum_stat_obs,tolerance_tab=tol,alpha=alpha,c=c)
#ABC_Drovandi
@

To perform the algorithm of Del Moral et al. (2012), one needs to specify five arguments: the initial number of simulations $nb\_simul$, the number $\alpha$ controlling the decrease in effective sample size of the particle set at each step, the number $M$ of simulations performed for each particle, the minimal effective sample size $nb\_threshold$ below which a resampling of particles is performed and the final tolerance level $tolerance\_target$.
Note that default values $alpha=0.5$, $M=1$ and $nb\_threshold=nb\_simul/2$ are used if not specified.
<<echo=TRUE,print=TRUE>>=
n=10
tol=5
alpha=0.5
M=1
n_t=5
#ABC_Delmoral<-ABC_sequential(method="Delmoral",model=trait_model,prior_matrix=priormatrix,
#nb_simul=n,summary_stat_target=sum_stat_obs,alpha=alpha,M=M,tolerance_target=tol)
#ABC_Delmoral
@

To perform the algorithm of Lenormand et al. (2012), one needs to specify three arguments: the initial number of simulations $nb\_simul$, the proportion $\alpha$ of best-fit simulations to update the tolerance level at each step, and the stopping criterion $p\_acc\_min$.
Note that default values $alpha=0.5$ and $p\_acc\_min=0.05$ are used if not specified, following Lenormand et al. (2012).
<<echo=TRUE,print=TRUE>>=
n=10
alpha=0.5
paccmin=0.4
n_t=5
#ABC_Lenormand<-ABC_sequentialmethod="Lenormand",model=trait_model,prior_matrix=priormatrix,
#nb_simul=n,summary_stat_target=sum_stat_obs,alpha=alpha,p_acc_min=paccmin)
#ABC_Lenormand
@


\subsection{Performing a ABC-MCMC scheme}
To perform the algorithm of Marjoram et al. (2003), one needs to specify five arguments: the number of sampled points $n\_obs$ in the Markov Chain, the number of chain points between two sampled points $n\_between\_sampling$, the maximal distance accepted between simulations and data $dist\_max$, an array $tab\_normalization$ precising the scale of each summary statistics, and an array $proposal\_range$ precising the maximal distances in each dimension of the parameter space for a jump of the MCMC.
<<echo=TRUE,print=TRUE>>=
n=10
nbetweensampling=1
distmax=8
tabnormalization=c(50,1,20,10000)
proposalrange=c(0,1,0.5,0,50,1)
#ABC_Marjoram_original<-ABC_mcmc(method="Marjoram_original",model=trait_model,prior_matrix=priormatrix,
#n_obs=n,n_between_sampling=nbetweensampling,summary_stat_target=sum_stat_obs,dist_max=distmax,
#tab_normalization=tabnormalization,proposal_range=proposalrange)
#ABC_Marjoram_original
@

To perform the algorithm of Marjoram et al. (2003) in which some of the arguments ($dist\_max$, $tab\_normalization$ and $proposal\_range$) are automatically determined by the algorithm, one needs to specify three arguments: the number $n\_calibration$ of simulations to perform at the calibration step, the tolerance quantile $tolerance\_quantile$ to be used for the determination of $dist\_max$ and the scale factor $proposal\_phi$ to determine the proposal range.
These modifications are drawn from the algorithm of Wegmann et al. (2009), without relying on PLS regressions.
The arguments are set by default to: $n\_calibration=10000$,$tolerance\_quantile=0.01$ and $proposal\_phi=1$.
<<echo=TRUE,print=TRUE>>=
n=10
nbetweensampling=1
ncalib=10
tolquantile = 0.5
proposalphi=1
#ABC_Marjoram<-ABC_mcmc(method="Marjoram",model=trait_model,prior_matrix=priormatrix,
#n_obs=n,n_between_sampling=nbetweensampling,summary_stat_target=sum_stat_obs,
#n_calibration=ncalib,tolerance_quantile=tolquantile,proposal_phi=proposalphi)
#ABC_Marjoram
@

To perform the algorithm of Wegmann et al. (2009), one needs to specify four arguments: the number $n\_calibration$ of simulations to perform at the calibration step, the tolerance quantile $tolerance\_quantile$ to be used for the determination of $dist\_max$, the scale factor $proposal\_phi$ to determine the proposal range and the number of components $numcomp$ to be used in PLS regressions.
The arguments are set by default to: $n\_calibration=10000$,$tolerance\_quantile=0.01$, $proposal\_phi=1$ and $numcomp=0$, this last default value encodes a choice of a number of PLS components equal to the number of summary statistics.
<<echo=TRUE,print=TRUE>>=
n=10
nbetweensampling=1
ncalib=10
tolquantile = 0.5
proposalphi=1
#ABC_Wegmann<-ABC_mcmc(method="Wegmann",model=trait_model,prior_matrix=priormatrix,
#n_obs=n,n_between_sampling=nbetweensampling,summary_stat_target=sum_stat_obs,
#n_calibration=ncalib,tolerance_quantile=tolquantile,proposal_phi=proposalphi,numcomp=0)
#ABC_Wegmann
@


\subsection{Using multiple cores}
Three additional functions are available in the package \texttt{EasyABC} to perform simulations on multiple cores of a computer: $ABC\_rejection\_cluster$, $ABC\_sequential\_cluster$ and $ABC\_mcmc\_cluster$.
These functions have the same arguments as their single core analogues, except that: 1- there is not anymore the argument $use\_seed$, which is forced to be TRUE; 2- there is a new argument $n\_cluster$ indicating the number of cores to be used. Its default value is equal to 1.


\section{Troubleshooting and development}
Please send comments, suggestions and bug reports to nicolas.dumoulin@irstea.fr or franck.jabot@irstea.fr 
Any new development of more efficient ABC schemes that could be included in the package is particularly welcome.

\section{Programming Acknowledgements}
The \texttt{EasyABC} package makes use of a number of \texttt{R} tools, among which:

- the \texttt{R} package \texttt{lhs} (Carnell 2009) for latin hypercube sampling.

- the \texttt{R} package \texttt{MASS} (Venables and Ripley 2002) for boxcox transformation.

- the \texttt{R} package \texttt{mnormt} (Genz and Azzalini 2011) for multivariate normal generation.

- the \texttt{R} package \texttt{pls} (Mevik and Wehrens 2011) for partial least square regression.

- the \texttt{R} script for the Wegmann et al. (2009)'s algorithm drawn from the \texttt{ABCtoolbox} documentation (Wegmann et al. 2009b).


\section{References}
Beaumont et al. 2009
Carnell 2009
Del Moral et al. 2012
Drovandi and Pettitt 2011
Genz and Azzalini 2011
Lenormand et al. 2012
Marjoram et al. 2003
Mevik and Wehrens 2011
Pritchard et al. 1999
Sisson et al. (2007)
Venables and Ripley 2002
Wegmann et al. (2009)
Wegmann et al. (2009b) - abctoolbox

\end{document}


